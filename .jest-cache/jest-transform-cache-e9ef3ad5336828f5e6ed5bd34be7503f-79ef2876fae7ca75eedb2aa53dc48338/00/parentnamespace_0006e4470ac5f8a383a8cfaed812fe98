69fedc00d5ac0740ac1a14b80adf6295
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParentNamespace = void 0;
const namespace_1 = require("./namespace");
const socket_io_adapter_1 = require("socket.io-adapter");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("socket.io:parent-namespace");
/**
 * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either
 * with a regular expression or with a function.
 *
 * @example
 * const parentNamespace = io.of(/\/dynamic-\d+/);
 *
 * parentNamespace.on("connection", (socket) => {
 *   const childNamespace = socket.nsp;
 * }
 *
 * // will reach all the clients that are in one of the child namespaces, like "/dynamic-101"
 * parentNamespace.emit("hello", "world");
 *
 */
class ParentNamespace extends namespace_1.Namespace {
  constructor(server) {
    super(server, "/_" + ParentNamespace.count++);
    this.children = new Set();
  }
  /**
   * @private
   */
  _initAdapter() {
    this.adapter = new ParentBroadcastAdapter(this);
  }
  emit(ev, ...args) {
    this.children.forEach(nsp => {
      nsp.emit(ev, ...args);
    });
    return true;
  }
  createChild(name) {
    debug("creating child namespace %s", name);
    const namespace = new namespace_1.Namespace(this.server, name);
    this["_fns"].forEach(fn => namespace.use(fn));
    this.listeners("connect").forEach(listener => namespace.on("connect", listener));
    this.listeners("connection").forEach(listener => namespace.on("connection", listener));
    this.children.add(namespace);
    if (this.server._opts.cleanupEmptyChildNamespaces) {
      const remove = namespace._remove;
      namespace._remove = socket => {
        remove.call(namespace, socket);
        if (namespace.sockets.size === 0) {
          debug("closing child namespace %s", name);
          namespace.adapter.close();
          this.server._nsps.delete(namespace.name);
          this.children.delete(namespace);
        }
      };
    }
    this.server._nsps.set(name, namespace);
    // @ts-ignore
    this.server.sockets.emitReserved("new_namespace", namespace);
    return namespace;
  }
  fetchSockets() {
    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
    // the behavior for namespaces created with a function is less clear
    // noteÂ²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
    // may exist on one node but not exist on another (since it is created upon client connection)
    throw new Error("fetchSockets() is not supported on parent namespaces");
  }
}
exports.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;
/**
 * A dummy adapter that only supports broadcasting to child (concrete) namespaces.
 * @private file
 */
class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {
  broadcast(packet, opts) {
    this.nsp.children.forEach(nsp => {
      nsp.adapter.broadcast(packet, opts);
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQYXJlbnROYW1lc3BhY2UiLCJuYW1lc3BhY2VfMSIsInJlcXVpcmUiLCJzb2NrZXRfaW9fYWRhcHRlcl8xIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsIk5hbWVzcGFjZSIsImNvbnN0cnVjdG9yIiwic2VydmVyIiwiY291bnQiLCJjaGlsZHJlbiIsIlNldCIsIl9pbml0QWRhcHRlciIsImFkYXB0ZXIiLCJQYXJlbnRCcm9hZGNhc3RBZGFwdGVyIiwiZW1pdCIsImV2IiwiYXJncyIsImZvckVhY2giLCJuc3AiLCJjcmVhdGVDaGlsZCIsIm5hbWUiLCJuYW1lc3BhY2UiLCJmbiIsInVzZSIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwib24iLCJhZGQiLCJfb3B0cyIsImNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcyIsInJlbW92ZSIsIl9yZW1vdmUiLCJzb2NrZXQiLCJjYWxsIiwic29ja2V0cyIsInNpemUiLCJjbG9zZSIsIl9uc3BzIiwiZGVsZXRlIiwic2V0IiwiZW1pdFJlc2VydmVkIiwiZmV0Y2hTb2NrZXRzIiwiRXJyb3IiLCJBZGFwdGVyIiwiYnJvYWRjYXN0IiwicGFja2V0Iiwib3B0cyJdLCJzb3VyY2VzIjpbInBhcmVudC1uYW1lc3BhY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbmNvbnN0IG5hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86cGFyZW50LW5hbWVzcGFjZVwiKTtcbi8qKlxuICogQSBwYXJlbnQgbmFtZXNwYWNlIGlzIGEgc3BlY2lhbCB7QGxpbmsgTmFtZXNwYWNlfSB0aGF0IGhvbGRzIGEgbGlzdCBvZiBjaGlsZCBuYW1lc3BhY2VzIHdoaWNoIHdlcmUgY3JlYXRlZCBlaXRoZXJcbiAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBpby5vZigvXFwvZHluYW1pYy1cXGQrLyk7XG4gKlxuICogcGFyZW50TmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gc29ja2V0Lm5zcDtcbiAqIH1cbiAqXG4gKiAvLyB3aWxsIHJlYWNoIGFsbCB0aGUgY2xpZW50cyB0aGF0IGFyZSBpbiBvbmUgb2YgdGhlIGNoaWxkIG5hbWVzcGFjZXMsIGxpa2UgXCIvZHluYW1pYy0xMDFcIlxuICogcGFyZW50TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICpcbiAqL1xuY2xhc3MgUGFyZW50TmFtZXNwYWNlIGV4dGVuZHMgbmFtZXNwYWNlXzEuTmFtZXNwYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIpIHtcbiAgICAgICAgc3VwZXIoc2VydmVyLCBcIi9fXCIgKyBQYXJlbnROYW1lc3BhY2UuY291bnQrKyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRBZGFwdGVyKCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgUGFyZW50QnJvYWRjYXN0QWRhcHRlcih0aGlzKTtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKG5hbWUpIHtcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcy5zZXJ2ZXIsIG5hbWUpO1xuICAgICAgICB0aGlzW1wiX2Zuc1wiXS5mb3JFYWNoKChmbikgPT4gbmFtZXNwYWNlLnVzZShmbikpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyhcImNvbm5lY3RcIikuZm9yRWFjaCgobGlzdGVuZXIpID0+IG5hbWVzcGFjZS5vbihcImNvbm5lY3RcIiwgbGlzdGVuZXIpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0aW9uXCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IG5hbWVzcGFjZS5fcmVtb3ZlO1xuICAgICAgICAgICAgbmFtZXNwYWNlLl9yZW1vdmUgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLmNhbGwobmFtZXNwYWNlLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2Uuc29ja2V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY2xvc2luZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZS5hZGFwdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLl9uc3BzLmRlbGV0ZShuYW1lc3BhY2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5zZXQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNlcnZlci5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICB9XG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBtYWtlIHRoZSBmZXRjaFNvY2tldHMoKSBtZXRob2Qgd29yayBmb3IgZHluYW1pYyBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIHJlZ2V4IChieSBzZW5kaW5nIHRoZVxuICAgICAgICAvLyByZWdleCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMsIGFuZCByZXR1cm5pbmcgdGhlIHNvY2tldHMgb2YgZWFjaCBtYXRjaGluZyBuYW1lc3BhY2UgZm9yIGV4YW1wbGUpLCBidXRcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGZvciBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIGZ1bmN0aW9uIGlzIGxlc3MgY2xlYXJcbiAgICAgICAgLy8gbm90ZcKyOiB3ZSBjYW5ub3QgbG9vcCBvdmVyIGVhY2ggY2hpbGRyZW4gbmFtZXNwYWNlLCBiZWNhdXNlIHdpdGggbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIGEgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICAgIC8vIG1heSBleGlzdCBvbiBvbmUgbm9kZSBidXQgbm90IGV4aXN0IG9uIGFub3RoZXIgKHNpbmNlIGl0IGlzIGNyZWF0ZWQgdXBvbiBjbGllbnQgY29ubmVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2hTb2NrZXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiBwYXJlbnQgbmFtZXNwYWNlc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IFBhcmVudE5hbWVzcGFjZTtcblBhcmVudE5hbWVzcGFjZS5jb3VudCA9IDA7XG4vKipcbiAqIEEgZHVtbXkgYWRhcHRlciB0aGF0IG9ubHkgc3VwcG9ydHMgYnJvYWRjYXN0aW5nIHRvIGNoaWxkIChjb25jcmV0ZSkgbmFtZXNwYWNlcy5cbiAqIEBwcml2YXRlIGZpbGVcbiAqL1xuY2xhc3MgUGFyZW50QnJvYWRjYXN0QWRhcHRlciBleHRlbmRzIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlciB7XG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB0aGlzLm5zcC5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBQ1osSUFBSUEsZUFBZSxHQUFJLFVBQVEsU0FBS0EsZUFBZSxJQUFLLFVBQVVDLEdBQUcsRUFBRTtFQUNuRSxPQUFRQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFJRCxHQUFHLEdBQUc7SUFBRSxTQUFT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